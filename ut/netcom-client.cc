/*
 *------------------------------------------------------------------------------
 *
 * netcom-client.cc
 *
 * Simple standalone netcom client program for the sentry
 *
 * You can start multiple clients with the same program. Args:
 *   hostname   IP address of the server
 *   portnum    server port for the control messages (stream uses portnum++)
 *   cid        camera ID, pick a unique number per client
 *
 * Connection with the server is done with 2 sockets:
 *   - control socket is used to send and receive
 *   - data socket is receive only (except for the session creation), it is
 *     used to receive camera frames and sensor data
 *
 * The control socket is secured with SSLv23, while the camera frames are secured
 * with a random key generated by the server during intialization for the client
 * Please refer to the README file for more details on the protocol
 *
 * The following keys are supported:
 *   WASD   moving and turning (once to start moving, again to stop)
 *   f      rotate camera up
 *   v      rotate camera down
 *   c      start/stop camera stream
 *   r      send a remote controller search command
 *   z      send a sensor data request message
 *   t      send a server terminate command
 *   q      exit client application
 *
 * Copyright (c) 2017 Zoltan Toth <ztoth AT thetothfamily DOT net>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 *
 *------------------------------------------------------------------------------
 */
#include <iostream>
#include <netdb.h>
#include <termios.h>
#include <unistd.h>
#include <signal.h>
#include <pthread.h>
#include <openssl/bio.h>
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <ctime>

#include "message.h"

/** hardcoded configuration */
const char *certfile = "../cfg/client/ca1_cert.pem";
const char *keyfile = "../cfg/client/ca1_key.pem";

/** socket variables */
SSL_CTX *ctx = NULL;
SSL *ssl = NULL;
int control_socket = -1;
int data_socket = -1;

/** window name */
std::stringstream cam_window_name;

/** secret key and client credentials from server */
char key[max_buf_size];
char otp[max_buf_size];
int client_id = 0;

/**
 * Send move command
 */
static bool
send_move_command (int direction)
{
    message_move_st *msg = new message_move_st;
    int length;

    msg->type = htonl(MESSAGE_MOVE);
    msg->direction = htonl(direction);
    length = SSL_write(ssl, msg, sizeof(*msg));

    if (length <= 0) {
        return false;
    }
    return true;
}

/**
 * Send command
 */
static bool
send_command (int type)
{
    message_st *msg = new message_st;
    int length;

    msg->type = htonl(type);
    length = SSL_write(ssl, msg, sizeof(*msg));

    if (length <= 0) {
        return false;
    }
    return true;
}

/**
 * Decode sensor data
 */
static void
decode_sensor_data (const message_sensor_st *sensor_msg)
{
    int sensor_type = ntohs(sensor_msg->sensor);
    int sensor_data = ntohs(sensor_msg->data);

    if (SENSOR_DISTANCE == sensor_type) {
        std::cout << "distance " << sensor_data << " cm" << std::endl;
    } else if (SENSOR_TEMPERATURE == sensor_type) {
        std::cout << "temperature " << sensor_data << " F ("
                  << (int)((sensor_data - 32) / 1.8) << " C)" << std::endl;
    } else {
        std::cout << "unknown sensor "
                  << sensor_type_str(static_cast<sensor_type_en>(sensor_type))
                  << ", data " << sensor_data << std::endl;
    }
}

/**
 * Decode frame data
 */
static void
decode_frame_data (const message_frame_st *frame_msg)
{
    static int frame_size = ntohl(frame_msg->frame_size);
    static int cols = ntohs(frame_msg->cols);
    static int rows = ntohs(frame_msg->rows);
    static int received_bytes = 0;
    static char framebuf[262140];
    static int frag_seq = ntohs(frame_msg->frag_seq);
    static bool force_resync = false;

    int curr_seq = ntohs(frame_msg->frag_seq);
    if (1 == curr_seq) {
        /* reset static vars */
        frame_size = ntohl(frame_msg->frame_size);
        cols = ntohs(frame_msg->cols);
        rows = ntohs(frame_msg->rows);
        received_bytes = 0;
        frag_seq = curr_seq;
        force_resync = false;
    } else if (force_resync) {
        /* skip until we get a new frame */
        return;
    }

    if (curr_seq != frag_seq) {
        std::cout << "wrong sequence " << curr_seq << ", expected "
                  << frag_seq << std::endl;
        if (curr_seq > frag_seq) {
            /* we lost a few fragments, skip the corresponding data in buffer */
            received_bytes += max_buf_size * (curr_seq - frag_seq);
            frag_seq = curr_seq;
        } else {
            /* we either lost a lot of fragments or got an old one */
            force_resync = true;
            return;
        }
    }

    /* copy frame data */
    int frag_size = ntohs(frame_msg->frag_size);
    memcpy(&framebuf[received_bytes], frame_msg->frame, frag_size);
    received_bytes += frag_size;
    frag_seq++;

    /* display frame if it's ready */
    if (received_bytes == frame_size) {
        /* decrypt frame with the secret key */
        int k = 0;
        for (int i = 0; i < received_bytes; i++) {
            framebuf[i] ^= key[k++];
            if (k >= max_buf_size) {
                k = 0;
            }
        }

        /*
         * Display the image, the window is opened/closed by the main thread,
         * thus it could happen that it's already closed when we try to show
         * the frame imshow returns error in that case, which we can safely
         * ignore
         */
        cv::Mat frame = cv::imdecode(cv::Mat(rows, cols, CV_8UC3, framebuf), -1);
        if (frame.rows > 0 && frame.cols > 0) {
            imshow(cam_window_name.str(), frame);
        }
        std::cout << time(NULL) << ": received frame, size " << received_bytes << std::endl;
    }
}

/**
 * This thread is responsible for listening to user input, and translating them
 * into messages for the server
 */
static void*
recv_thread (void *arg)
{
    char buf[65535];

    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);

    while (true) {
        int length = recvfrom(data_socket, buf, sizeof(buf), 0, NULL, NULL);
        if (length <= 0) {
            std::cout << "server hung up" << std::endl;
            /* TODO: send a quit event to the main thread */
            break;
        }

        message_st *msg = reinterpret_cast<message_st*>(buf);
        message_type_en type = static_cast<message_type_en>(ntohl(msg->type));

        switch (type) {
        case MESSAGE_CAMERA_FRAME: {
            message_frame_st *frame_msg = reinterpret_cast<message_frame_st*>(msg);
            decode_frame_data(frame_msg);
            break;
        }

        case MESSAGE_SENSOR_DATA: {
            message_sensor_st *sensor_msg = reinterpret_cast<message_sensor_st*>(msg);
            decode_sensor_data(sensor_msg);
            break;
        }

        default:
            std::cout << "unknown message, type " << message_type_str(type)
                      << ", length " << length << std::endl;
            break;
        }
    }

    pthread_exit(NULL);
}

/**
 * Heartbeat thread
 */
static void*
heartbeat_thread (void *arg)
{
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);

    while (true) {
        send_command(MESSAGE_HEARTBEAT);
        sleep(1);
    }

    return NULL;
}

/**
 * Signal handler
 */
static void
signal_callback (int signal)
{
    std::cout << "please press 'q' to exit" << std::endl;
}

/**
 * Cleanup netcom
 */
static void
cleanup_netcom ()
{
    /* release the SSL sessions, contexts and sockets */
    if (ssl) {
        SSL_free(ssl);
    }
    if (ctx) {
        SSL_CTX_free(ctx);
    }
    if (-1 != control_socket) {
        close(control_socket);
    }
    if (-1 != data_socket) {
        close(data_socket);
    }
}

/**
 * Open the control socket
 */
static void
open_control_socket (char *server, char *port)
{
    /* initialize SSL library */
    SSL_library_init();
    OpenSSL_add_all_algorithms();
    SSL_load_error_strings();

    /* initialize SSL context */
    ctx = SSL_CTX_new(SSLv23_client_method());
    if (NULL == ctx) {
        std::cout << "Control SSL context initialization failed" << std::endl;
        exit(EXIT_FAILURE);
    }

    /* load client certificate file */
    if (SSL_CTX_use_certificate_file(ctx, certfile, SSL_FILETYPE_PEM) <= 0) {
        std::cout << "invalid or non-existing certificate file " << certfile
                  << std::endl;
        cleanup_netcom();
        exit(EXIT_FAILURE);
    }

    /* load the client private key file */
    if (SSL_CTX_use_PrivateKey_file(ctx, keyfile, SSL_FILETYPE_PEM) <= 0) {
        std::cout << "invalid or non-existing key file " << keyfile << std::endl;
        cleanup_netcom();
        exit(EXIT_FAILURE);
    }

    /* create control socket */
    struct addrinfo hints, *results, *rp;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if (getaddrinfo(server, port, &hints, &results) != 0) {
        std::cout << "getaddrinfo() failed for the control socket" << std::endl;
        cleanup_netcom();
        exit(EXIT_FAILURE);
    }

    control_socket = -1;
    for (rp = results; rp != NULL; rp = rp->ai_next) {
        control_socket = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (-1 == control_socket) {
            continue;
        }

        if (connect(control_socket, rp->ai_addr, rp->ai_addrlen) != -1) {
            /* success */
            break;
        } else {
            control_socket = -1;
        }
    }
    freeaddrinfo(results);

    if (-1 == control_socket) {
        std::cout << "unable to create control socket" << std::endl;
        cleanup_netcom();
        exit(EXIT_FAILURE);
    }

    /* set read timeout for the control socket */
    struct timeval timeout;
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;
    if (setsockopt(control_socket, SOL_SOCKET, SO_RCVTIMEO,
                   (char *)&timeout, sizeof(timeout)) < 0) {
        std::cout << "setsockopt() failed with " << errno << std::endl;
    }

    /* initiate SSL connection with the server */
    ssl = SSL_new(ctx);
    SSL_set_fd(ssl, control_socket);
    if (-1 == SSL_connect(ssl)) {
        std::cout << "SSL_connect() failed" << std::endl;
        cleanup_netcom();
        exit(EXIT_FAILURE);
    }

    /* connection established successfully */
    std::cout << "connected with " << SSL_get_cipher(ssl) << " encryption"
              << std::endl;
    X509 *cert = SSL_get_peer_certificate(ssl);
    if (NULL != cert) {
        std::cout << "server certificate issuer: "
                  << X509_NAME_oneline(X509_get_issuer_name(cert), 0, 0)
                  << std::endl;
    } else {
        std::cout << "no server certificates available" << std::endl;
    }
}

/**
 * Wait for client credentials from server
 */
static void
wait_for_credentials ()
{
    while (0 == client_id) {
        char buf[sizeof(message_connect_st)];
        std::cout << "waiting for client credentials" << std::endl;
        if (SSL_read(ssl, buf, sizeof(buf)) != sizeof(buf)) {
            continue;
        }

        message_connect_st *msg = reinterpret_cast<message_connect_st*>(buf);
        message_type_en type = static_cast<message_type_en>(ntohl(msg->type));
        if (type != MESSAGE_NETCOM_CONNECT) {
            std::cout << "received message is not credentials, type "
                      << message_type_str(type) << std::endl;
        } else {
            client_id = ntohl(msg->id);
            memcpy(otp, msg->otp, sizeof(msg->otp));
            std::cout << "received client credentials, ID "
                      << client_id << std::endl;
        }
    }
}

/**
 * Open the data socket
 */
static void
open_data_socket (char *server, char *port)
{
    /* create a client side socket for the uplink */
    struct addrinfo hints, *results, *rp;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_DGRAM;

    if (getaddrinfo(server, port, &hints, &results) != 0) {
        std::cout << "getaddrinfo() failed for data socket" << std::endl;
        cleanup_netcom();
        exit(EXIT_FAILURE);
    }

    data_socket = -1;
    for (rp = results; rp != NULL; rp = rp->ai_next) {
        data_socket = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (-1 == data_socket) {
            continue;
        }

        /* connect the socket so we don't have to remember the address */
        if (connect(data_socket, rp->ai_addr, rp->ai_addrlen) != -1) {
            /* success */
            break;
        } else {
            data_socket = -1;
        }
    }
    freeaddrinfo(results);

    if (-1 == data_socket) {
        std::cout << "unable to create data socket" << std::endl;
        cleanup_netcom();
        exit(EXIT_FAILURE);
    }
}

/**
 * Wait for key from server
 */
static void
wait_for_key ()
{
    /* send our credentials to server via UDP then server will give us our key */
    key[0] = 0;
    if (data_socket > 0) {
        message_connect_st *msg = new message_connect_st;
        msg->type = htonl(MESSAGE_NETCOM_CONNECT);
        msg->id = htonl(client_id);
        memcpy(msg->otp, otp, sizeof(otp));

        while (0 == key[0]) {
            std::cout << "sending client credentials to server" << std::endl;
            send(data_socket, msg, sizeof(*msg), 0);

            std::cout << "waiting for key" << std::endl;
            char buf[sizeof(message_key_st)];
            if (SSL_read(ssl, buf, sizeof(buf)) > 0) {
                message_key_st *key_msg = reinterpret_cast<message_key_st*>(buf);
                message_type_en type =
                    static_cast<message_type_en>(ntohl(key_msg->type));
                if (type != MESSAGE_NETCOM_KEY) {
                    std::cout << "message is NOT key, type "
                              << message_type_str(type) << std::endl;
                } else {
                    std::cout << "received key" << std::endl;
                    memcpy(key, key_msg->key, sizeof(key_msg->key));
                }
            }
        }

        delete msg;
    }
}

/**
 * Main function
 */
int
main (int argc, char *argv[])
{
    /* GPL notice */
    std::cout << "Sentry home monitoring robot - client program" << std::endl;
    std::cout << "Copyright (c) 2017 Zoltan Toth <ztoth AT thetothfamily DOT net>" << std::endl;
    std::cout << "This program comes with ABSOLUTELY NO WARRANTY; This is free software," << std::endl;
    std::cout << "and you are welcome to redistribute it under certain conditions;" << std::endl;
    std::cout << "Please refer to COPYING for details." << std::endl << std::endl;

    /* block ctrl+c (FIXME: pthread safe signal handling) */
    signal(SIGINT, signal_callback);

    /* we are expecting 3 arguments */
    if (argc != 4) {
        std::cout << "usage: " << argv[0] << " <hostname> <portnum> <cid>" << std::endl;
        exit(EXIT_FAILURE);
    }

    /* save the args */
    char *server = argv[1];
    char *port = argv[2];
    cam_window_name << "camera " << argv[3];

    /* open the control socket */
    open_control_socket(server, port);

    /* read the client credentials from server */
    wait_for_credentials();

    /* control socket is ready, now we need to open the data socket */
    open_data_socket(server, port);

    /* read the key from server */
    wait_for_key();

    /* fire up a thread for processing messages from the server */
    pthread_t recv_thrd;
    pthread_create(&recv_thrd, 0, recv_thread, NULL);

    /* fire up a thread for sending heartbeats */
    pthread_t heartbeat_thrd;
    pthread_create(&heartbeat_thrd, 0, heartbeat_thread, NULL);

    /* the main thread will be listening to the user input */
    struct termios term;
    tcgetattr(STDIN_FILENO, &term);
    term.c_lflag &= ~(ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &term);

    /* open the camera window (0 to make it resizable) */
    cv::namedWindow(cam_window_name.str(), 0);
    cv::startWindowThread();

    /* print a little help screen */
    std::cout << "init complete, ready for action" << std::endl;
    std::cout << "supported keys:" << std::endl
              << "  WASD   moving and turning (once to start moving, again to stop)" << std::endl
              << "  f      rotate camera up" << std::endl
              << "  v      rotate camera down" << std::endl
              << "  c      start/stop camera stream" << std::endl
              << "  r      send a remote controller search command" << std::endl
              << "  z      send a sensor data request message" << std::endl
              << "  t      send a server terminate command" << std::endl
              << "  q      exit client application" << std::endl;
    std::cout << "================================" << std::endl;

    /* get sensor information on startup */
    send_command(MESSAGE_SENSOR_REQUEST);

    bool loop = true;
    while (loop) {
        switch (getchar()) {
        case 'w': {
            std::cout << "move forward command" << std::endl;
            loop = send_move_command(MOVE_FORWARD);
            break;
        }

        case 'a': {
            std::cout << "turn left command" << std::endl;
            loop = send_move_command(TURN_LEFT);
            break;
        }

        case 's': {
            std::cout << "move backward command" << std::endl;
            loop = send_move_command(MOVE_BACKWARD);
            break;
        }

        case 'd': {
            std::cout << "turn right command" << std::endl;
            loop = send_move_command(TURN_RIGHT);
            break;
        }

        case 'f': {
            std::cout << "rotate camera up command" << std::endl;
            loop = send_move_command(ROTATE_UP);
            break;
        }

        case 'v': {
            std::cout << "rotate camera down command" << std::endl;
            loop = send_move_command(ROTATE_DOWN);
            break;
        }

        case 'c': {
            std::cout << "sending stream command, window "
                      << cam_window_name.str() << std::endl;
            loop = send_command(MESSAGE_CAMERA_REQUEST);
            break;
        }

        case 'r': {
            std::cout << "search for remote controllers" << std::endl;
            loop = send_command(MESSAGE_SEARCH_REMOTE);
            break;
        }

        case 'z': {
            std::cout << "request sensor data" << std::endl;
            loop = send_command(MESSAGE_SENSOR_REQUEST);
            break;
        }

        case 't': {
            std::cout << "sending terminate command" << std::endl;
            send_command(MESSAGE_TERMINATE);
            loop = false;
            break;
        }

        case 'q': {
            std::cout << "exit application" << std::endl;
            loop = false;
            break;
        }

        default:
            break;
        }
    }

    /* cleanup */
    std::cout << "cleaning up" << std::endl;

    /* reset terminal echo */
    term.c_lflag |= (ICANON | ECHO);
    tcsetattr(STDIN_FILENO, TCSANOW, &term);

    /* close camera window */
    cv::destroyWindow(cam_window_name.str());

    /* destroy the threads */
    pthread_cancel(recv_thrd);
    pthread_join(recv_thrd, NULL);
    pthread_cancel(heartbeat_thrd);
    pthread_join(heartbeat_thrd, NULL);

    /* cleanup netcom */
    cleanup_netcom();

    return 0;
}
